---
title: "Using Rust code in R Markdown documents"
author: "Claus O. Wilke"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{RMarkdown}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

## R Markdown

The rextendr package enables a new chunk type for knitr, `extendr`, which compiles and evaluates Rust code.

First, you need to load the rextendr package in a regular R chunk. You would normally do this in a hidden setup chunk at the top of your R Markdown document.
```{r}
library(rextendr)
```


Then, you can create a code chunk of type `extendr`. For example:
````markdown
`r ''````{extendr}
rprintln!("Hello from Rust!");

let x = 5;
let y = 7;
let z = x*y;

z
```
````
This chunk generates the following output:
```{extendr}
rprintln!("Hello from Rust!");

let x = 5;
let y = 7;
let z = x*y;

z
```

In the background, the `extendr` knit engine casts the Rust integer variable into type `Robj` and returns its value to R. Notice the lack of a semicolon (`;`) at the end of this line, to indicate that you want to return a value. You can also write code that doesn't return any result to R. In this case, the last line would end in a semicolon, as in this example:
```{extendr}
let x = 5;
let y = 7;
let z = x*y;

rprintln!("{}*{} = {}", x, y, z);
```

## Communicating between R and Rust

It is possible to access variables defined in R from Rust. Let's define two R variables, a numeric and a string:

```{r}
x <- 5.3
y <- "hello"
```

We can read these variables from Rust using the `R!()` macro. Unfortunately, it takes a bit of unwrapping and type-converting to get these into native Rust values. This is the case because things could go wrong at each step, and we're ignoring the errors with `unwrap()`. For example, `R!()` calls the R interpreter and it could generate an error. And even if it returns a value, we're not guaranteed that the value can be coerced into a real value or a string, so `as_real()` and `as_str()` can also error out.

```{extendr}
let x:f64 = R!(x).unwrap().as_real().unwrap();
let y:String = R!(y).unwrap().as_str().unwrap().to_string();
rprintln!("{} {}", y, x);
```
